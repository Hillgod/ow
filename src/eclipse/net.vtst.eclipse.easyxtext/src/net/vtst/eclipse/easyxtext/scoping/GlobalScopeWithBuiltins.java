// EasyXtext
// (c) Vincent Simonet, 2011
package net.vtst.eclipse.easyxtext.scoping;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;

/**
 * Global scope generated by
 * {@link net.vtst.eclipse.easyxtext.scoping.EasyBuiltinGlobalScopeProvider}.
 * 
 * <p>
 * Scope joining a global scope with a builtin scope. Elements are looked up
 * first in the global scope, and then in the builtin scope. It is similar to
 * {@code org.eclipse.xtext.scoping.MapBasedScope}, but it work in the other way
 * around (here, the map is looked <em>after</em> the parent scope).
 * </p>
 * 
 * <p>
 * This class is used by
 * {@link net.vtst.eclipse.easyxtext.scoping.EasyBuiltinGlobalScopeProvider} for
 * returning scopes.
 * </p>
 * 
 * @author vtst
 * 
 */
public class GlobalScopeWithBuiltins implements IScope {

  private LinkedHashMap<QualifiedName, IEObjectDescription> builtins = new LinkedHashMap<QualifiedName, IEObjectDescription>(
      4);
  private IScope globalScope;

  /**
   * Create a new scope object, which do not ignore case. Same as
   * {@code GlobalScopeWithBuiltins(builtins, globalScope, false)}.
   * 
   * @param globalScope
   *          The parent global scope.
   * @param builtins
   *          An iterable of builtin EObjectDescriptions.
   */
  public GlobalScopeWithBuiltins(IScope globalScope,
      Iterable<IEObjectDescription> builtins) {
    this.globalScope = globalScope;
    boolean ignoreCase = isIgnoreCase();
    for (IEObjectDescription description : builtins) {
      QualifiedName name = ignoreCase ? description.getName().toLowerCase()
          : description.getName();
      IEObjectDescription previous = this.builtins.put(name, description);
      // we are optimistic that no duplicate names are used
      // however, if the name was already used, the first one should win
      if (previous != null) {
        this.builtins.put(name, previous);
      }
    }
  }

  protected boolean isIgnoreCase() {
    return false;
  }

  /**
   * Return the object description associated with the given name in the scope,
   * or null if the name is not bound in the scope. The global scope is looked
   * up before the builtins.
   * 
   * @param name
   *          The qualified name to look for
   * @return The associated object description, or null.
   * @see org.eclipse.xtext.scoping.IScope#getSingleElement(org.eclipse.xtext.naming.QualifiedName)
   */
  @Override
  public IEObjectDescription getSingleElement(QualifiedName name) {
    IEObjectDescription objectDescription = globalScope.getSingleElement(name);
    if (objectDescription != null)
      return objectDescription;
    return getBuiltinElementByName(name);
  }

  /**
   * Return the object description associated with the given name in the builtin
   * scope, or null if the name is not bound in the scope.
   * 
   * @param name
   *          The qualified name to look for.
   * @return The associated object description, or null.
   */
  protected IEObjectDescription getBuiltinElementByName(QualifiedName name) {
    if (isIgnoreCase()) {
      return builtins.get(name.toLowerCase());
    } else {
      return builtins.get(name);
    }
  }

  /**
   * Get the elements associated with the given name in the scope.
   * 
   * @param name
   *          The qualified name to look for.
   * @return An iterable over the object descriptions.
   * @see org.eclipse.xtext.scoping.IScope#getElements(org.eclipse.xtext.naming.QualifiedName)
   */
  @Override
  public Iterable<IEObjectDescription> getElements(QualifiedName name) {
    Iterable<IEObjectDescription> globalElements = globalScope
        .getElements(name);
    if (!Iterables.isEmpty(globalElements))
      return globalElements;
    IEObjectDescription objectDescription = getBuiltinElementByName(name);
    if (objectDescription == null)
      return Collections.emptyList();
    else
      return Collections.singleton(objectDescription);
  }

  /**
   * Return the object description associated with the given object in the
   * scope, or null if the object is not in the scope. The global scope is
   * looked up before the builtins.
   * 
   * @param object
   *          The object to look for.
   * @return The associated object description, or null.
   * @see org.eclipse.xtext.scoping.IScope#getSingleElement(org.eclipse.emf.ecore.EObject)
   */
  @Override
  public IEObjectDescription getSingleElement(EObject object) {
    Iterable<IEObjectDescription> elements = getElements(object);
    Iterator<IEObjectDescription> iterator = elements.iterator();
    if (iterator.hasNext()) {
      IEObjectDescription result = iterator.next();
      return result;
    }
    return null;
  }

  @Override
  public Iterable<IEObjectDescription> getElements(EObject object) {
    final URI uri = EcoreUtil2.getNormalizedURI(object);
    Iterable<IEObjectDescription> globalElements = globalScope
        .getElements(object);
    Iterable<IEObjectDescription> builtinElements = getBuiltinElementsByEObject(
        object, uri);
    return Iterables.concat(globalElements, builtinElements);
  }

  private Iterable<IEObjectDescription> getBuiltinElementsByEObject(
      final EObject object, final URI uri) {
    Iterable<IEObjectDescription> builtinElements = builtins.values();
    Iterable<IEObjectDescription> result = Iterables.filter(builtinElements,
        new Predicate<IEObjectDescription>() {
          public boolean apply(IEObjectDescription input) {
            if (input.getEObjectOrProxy() == object)
              return canBeFoundByName(input);
            if (uri.equals(input.getEObjectURI())) {
              return canBeFoundByName(input);
            }
            return false;
          }

          public boolean canBeFoundByName(IEObjectDescription input) {
            IEObjectDescription lookUp = getBuiltinElementByName(input
                .getName());
            if (lookUp != null) {
              if (lookUp == input)
                return true;
              if (lookUp.getEObjectOrProxy() == object)
                return true;
              if (uri.equals(lookUp.getEObjectURI()))
                return true;
            }
            return false;
          }
        });
    return result;
  }

  @Override
  public Iterable<IEObjectDescription> getAllElements() {
    Iterable<IEObjectDescription> globalElements = globalScope.getAllElements();
    Iterable<IEObjectDescription> builtinElements = builtins.values();
    return Iterables.concat(globalElements, builtinElements);
  }
}
